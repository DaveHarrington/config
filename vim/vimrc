"***********************************************"
" All custom keybindings
"
"***********************************************"

"Pathogen Init
source ~/config/vim/bundle/vim-pathogen/autoload/pathogen.vim
if exists("*pathogen#infect")
  "let g:pathogen_disabled=[]
  call pathogen#infect()
endif

let mapleader = ','

"Surround
" cs"'
" ds"
" yss" #line
" ysiw" #word

"sudo
":e sudo:/etc/passwd

" Quicklist
nnoremap ]q :cnext<cr>
nnoremap [q :cprevious<cr>

"comment
" n:gcc
" v:gc
let g:tcommentMapLeader1 = ''
let g:tcommentMapLeader2 = ''
let g:tcommentMapLeaderOp2 = ''

let g:EasyMotion_do_mapping = 0
vnoremap gw :<C-U>call EasyMotion#WB(1, 0)<CR>
inoremap gw :call EasyMotion#WB(0, 0)<CR>
onoremap gw :call EasyMotion#WB(0, 0)<CR>
nnoremap gw :call EasyMotion#WB(0, 0)<CR>
vnoremap gW :<C-U>call EasyMotion#WB(1, 1)<CR>
inoremap gW :call EasyMotion#WB(0, 1)<CR>
onoremap gW :call EasyMotion#WB(0, 1)<CR>
nnoremap gW :call EasyMotion#WB(0, 1)<CR>

"tslime
vmap <C-c><C-c> "ry :call Send_to_Tmux(@r)<CR>

"neocomplcache
imap <C-k> <Plug>(neocomplcache_snippets_expand)
smap <C-k> <Plug>(neocomplcache_snippets_expand)
inoremap <expr><C-g> neocomplcache#undo_completion()
inoremap <expr><C-l> neocomplcache#complete_common_string()
inoremap <expr><CR> neocomplcache#smart_close_popup() . "\<CR>"

" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
inoremap <expr><C-e>  neocomplcache#cancel_popup()

"Gundo
map <leader>u :GundoToggle<CR>

" Smart grep
map <Leader>g :TBGS
map <Leader>w :TBGW<CR>

let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_use_caching = 1
let g:ctrlp_switch_buffer = ''
let g:ctrlp_clear_cache_on_exit = 0
let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
let g:ctrlp_extensions = ['tag']
map <C-y> :CtrlPMRU<CR>

"Remove all trailing whitespace
nnoremap <silent> <F3> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>
map <F4> :syntax sync fromstart<CR>
au FileType python imap <buffer> <F7> import pdb; pdb.set_trace() #FIXME
au FileType php imap <buffer> <F7> hphpd_break(); //FIXME

" Inserts the path of the currently edited file into a command
" Command mode: Ctrl+P
cmap <C-P> <C-R>=expand("%:p:h") . "/" <CR>

" Match tmux
noremap <c-w><c-i> :tabprev<cr>
noremap <c-w><c-o> :tabnext<cr>
noremap <c-w><c-t> :tabnew<cr>

" Fix annoying fold defaults
" fold all
noremap FJ zM
" unfold all
noremap FK zR
" toggle fold on method
noremap FL zA

ca BD bufdo bdelete

" Edit/reload the vimrc file
nmap <silent> <leader>ev :e $MYVIMRC<CR>
nmap <silent> <leader>sv :so $MYVIMRC<CR>

"Clear highlights with ,/
nmap <silent> <leader>/ :nohlsearch<CR>

"************************"
" Annoyances

command! W w

cnoremap <C-k> <UP>
cnoremap <C-j> <DOWN>

" Annoying when you have just hit shift v for visual mode!
vnoremap <S-j> j
vnoremap <S-k> k

"Don't drop select after indent
vnoremap > >gv
vnoremap < <gv

"************************"

" Status line config
set statusline=
set statusline +=\ %n\ %*            "buffer number
set statusline +=venv=%{virtualenv#statusline()}
set statusline +=\ %<%F%*            "full path
set statusline +=%m%*                "modified flag
set statusline+=%=                           " right align
set statusline +=%{v:register}
set statusline +=%y%*                "file type
set statusline +=%l%*                  "current line
set statusline +=/%L%*               "total lines
set statusline +=\ %c%*             "column number

"************************"
" Cursor line
autocmd InsertEnter * set cul
autocmd InsertLeave * set nocul

if version >= 700
  set colorcolumn:81
endif

" Omnicomplete
set complete-=i
set completeopt+=longest

"folding settings
set foldmethod=indent   "fold based on indent
set foldnestmax=10      "deepest fold is 10 levels
set nofoldenable        "dont fold by default
set foldlevel=1         "this is just what i use

" Intuitive backspacing in insert mode
set backspace=indent,eol,start

" Set encoding
set encoding=utf-8

" Whitespace stuff
set nowrap
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set list listchars=tab:\ \ ,trail:Â·

" Searching
set hlsearch
set incsearch
set ignorecase
set smartcase

" Tab completion
set wildmode=list:longest,list:full
set wildignore+=*.o,*.obj,.git,*.rbc,*.class,.svn,vendor/gems/*

" Status bar
set laststatus=2

" enable using the mouse if terminal emulator
" supports it (xterm does)
set mouse=a
set ttymouse=xterm2

" Eh, swapfiles
set nobackup
set noswapfile

" Wrap at 72 chars for comments.
set formatoptions=cq textwidth=72 foldignore= wildignore+=*.py[co]

" Python
let python_highlight_all = 1
" let g:pydoc_cmd = "/usr/local/bin/pydoc"
" let g:pydoc_open_cmd = "vsplit"
" let g:pydoc_perform_mappings = 0
"au FileType python,man silent map <buffer> <leader>pd :call ShowPyDoc('<C-R><C-W>', 1)<CR>
let g:virtualenv_auto_activate = 1
" PyFlakes highlighting
highlight clear SpellBad highlight SpellBad term=underline cterm=underline gui=underline

" Other
au FileType htmldjango set wrap nolist breakat==}>
au FileType json set equalprg=json_reformat
au BufNewFile,BufRead *.cconf set filetype=python
au BufRead *.vis so %

let g:NERDCustomDelimiters = {
    \ 'htmldjango': { 'left': '{% comment %}','right': '{% endcomment %}' },
    \ }

" load the plugin and indent settings for the detected filetype
filetype on
filetype plugin indent on

" Stuff
set modeline
set modelines=10
set splitbelow
set splitright
set nocompatible
set title
set hidden
set ruler
set history=1000
set scrolloff=3
set number
set switchbuf=useopen
set autoread
set showcmd
syntax on

"Scroll through long lines properly
nnoremap j gj
nnoremap k gk

"Persistent undo
silent !mkdir -vp ~/.backup/vim/undo/ > /dev/null 2>&1
set undofile
set undodir=~/.backup/vim/undo/,~/tmp,.

set t_Co=256
color dave256

function! FindAndEdit(filename)
  let l:filesplit = split(a:filename, "/")
  let l:cwd = split(getcwd(), "/")
  let l:ind = index(cwd, filesplit[0])
  if l:ind > 0
    " If the root of the searched file is in the cwd tree
    let l:filesplit = [''] + l:cwd[0:l:ind-1] + l:filesplit
  endif
  execute "edit " . join(l:filesplit, "/")
endfunction

command! -nargs=1 F :call FindAndEdit('<args>')
